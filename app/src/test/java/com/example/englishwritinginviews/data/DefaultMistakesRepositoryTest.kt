package com.example.englishwritinginviews.data

import com.example.englishwritinginviews.data.api.ApiService
import com.example.englishwritinginviews.data.api.entities.MistakeApiModel
import com.example.englishwritinginviews.data.db.LocalDataSource
import com.example.englishwritinginviews.domain.QuestionDomain
import com.example.englishwritinginviews.domain.WorkResult
import com.example.englishwritinginviews.testUtils.createListOfQuestionDomain
import com.example.englishwritinginviews.testUtils.createQuestionDomain
import io.mockk.coEvery
import io.mockk.every
import io.mockk.mockk
import kotlinx.coroutines.ExperimentalCoroutinesApi
import kotlinx.coroutines.delay
import kotlinx.coroutines.flow.flowOf
import kotlinx.coroutines.flow.toList
import kotlinx.coroutines.runBlocking
import kotlinx.coroutines.test.runTest
import org.junit.Assert.assertEquals
import org.junit.Assert.assertTrue
import org.junit.Before
import org.junit.Test
import retrofit2.Response

class DefaultMistakesRepositoryTest {

    private lateinit var apiService: ApiService
    private lateinit var localDataSource: LocalDataSource
    private lateinit var defaultMistakesRepository: DefaultMistakesRepository

    @Before
    fun setup() {
        apiService = mockk()
        localDataSource = mockk()
        defaultMistakesRepository = DefaultMistakesRepository(apiService, localDataSource)
    }

    @Test
    fun `safeApiCall Returns Value Generated By Block`() = runBlocking {
        val block = createMockedBlock()
        coEvery { block() } returns Response.success("test")

        val result = defaultMistakesRepository.safeApiCall { block() }
        var string = ""
        result.collect {
            string = when (it) {
                is WorkResult.Success -> it.data.toString()
                is WorkResult.Error -> it.message.toString()
                else -> "loading"
            }
        }

        assertEquals("test", string)
    }

    @Test
    fun `safeApiCall Throws Exception`() = runBlocking {
        val block = createMockedBlock()
        coEvery { block() } throws Exception("Test")

        val result = defaultMistakesRepository.safeApiCall { block() }
        var string = ""
        result.collect {
            string = when (it) {
                is WorkResult.Success -> it.data.toString()
                is WorkResult.Error -> it.message.toString()
                else -> "loading"
            }
        }

        assertEquals("Api call failed Test", string)
    }

    @OptIn(ExperimentalCoroutinesApi::class)
    @Test
    fun `safeApiCalls Loading State`() = runTest {
        val block = createMockedBlock()
        coEvery { block() } coAnswers {
            delay(1000)
            Response.success("Test")
        }

        val loadingFlow = defaultMistakesRepository.safeApiCall { block() }
        val result = loadingFlow.toList()

        assertTrue(result.first() is WorkResult.Loading)
    }

    @Test
    fun `fetchMistakes Returns List Of Mistakes`() = runBlocking {
        coEvery { apiService.fetchMistakes("test") } returns Response.success(MistakeApiModel())

        val expected = Response.success(MistakeApiModel())
        val result = apiService.fetchMistakes("test")

        assertEquals(expected.code(), result.code())
        assertEquals(expected.body(), result.body())
    }

    @Test
    fun `getQuestions should return Flow`() = runBlocking {
        val list = setOf("Filter 1", "Filter 2")
        coEvery { localDataSource.getQuestions(list) } returns flowOf(
            createListOfQuestionDomain(
                true,
                1
            )
        )

        val result = mutableListOf<QuestionDomain>()
        defaultMistakesRepository.getQuestions(list).collect {
            it.map { model ->
                result.add(model)
            }
        }
        val expected = createListOfQuestionDomain(true, 1)

        assertEquals(expected, result)
    }

    @Test
    fun `getAnsweredQuestions should return Flow`() = runBlocking {
        coEvery { localDataSource.getAnsweredQuestions() } returns flowOf(
            createListOfQuestionDomain(
                true,
                1
            )
        )

        val result = mutableListOf<QuestionDomain>()
        defaultMistakesRepository.getAnsweredQuestions().collect {
            it.map { model ->
                result.add(model)
            }
        }
        val expected = createListOfQuestionDomain(true, 1)

        assertEquals(expected, result)
    }

    @Test
    fun `updateAnswer returns QuestionDomain`() {
        every {
            localDataSource.updateAnswer(
                1,
                "",
                1111L,
                1.1f
            )
        } returns createQuestionDomain(true)

        val result = defaultMistakesRepository.updateAnswer(1, "", 1111L, 1.1f)
        val expected = createQuestionDomain(true)

        assertEquals(expected, result)
    }


    private fun createMockedBlock(): suspend () -> Response<String> {
        try {
            return mockk()
        } catch (e: Exception) {
            throw Exception("Test")
        }
    }

}
